#include <gps.h>
#include <Arduino.h>
#include <SoftwareSerial.h>
#include <TinyGPS++.h>
#include <serverESP.h>
#include <main.h>
#include <Preferences.h>
#include <timer.h>

// The TinyGPS++ object
TinyGPSPlus gps;

static const int RXPin = 16, TXPin = 17;
static const uint32_t GPSBaud = 9600;

// The serial connection to the GPS device
SoftwareSerial ss(RXPin, TXPin);

Timer dataTimer;

GPSDataRecorder recoveryData("Recov");
GPSDataRecorder zippingData("Zip");

//put everything in the right units and the right data structure

GPSDataRecorder::GPSDataRecorder(const String& identifier) {
  storageID = identifier;
  maxSpeedKey = "MaxSpeed" + storageID;
  distanceKey = "Distance" + storageID;
  timeKey = "Time" + storageID;

  lastMaxSpeed = 0.0;
  maxSpeed = 0.0;
  ATMaxSpeed = preferences.getFloat(maxSpeedKey.c_str(), 0.0); //All time max speed get from spiffs
  lastDistance = 0.0;
  distance = 0.0;
  ATDistance = preferences.getFloat(distanceKey.c_str(), 0.0);  //all time distance 
  lastTime = 0;
  time = 0;
  ATTime = preferences.getUInt(timeKey.c_str(), 0);   //all combined time 
  ATAvg = (ATDistance/ATTime) *0.682; //feet/sec to MPH

}

void GPSDataRecorder::recordSpeed(){
  double currentSpeed = gps.speed.mph();
  if (currentSpeed > lastMaxSpeed) {
    lastMaxSpeed = currentSpeed;
  }
}

void GPSDataRecorder::startRecord(){
  lastMaxSpeed = 0.0;
  dataTimer.start();
  startingLat = gps.location.lat();
  startingLong = gps.location.lng();

}

void GPSDataRecorder::endRecord(){
  lastTime = dataTimer.getTime()/1000;

  lastDistance = gps.distanceBetween(startingLat, startingLong, gps.location.lat(), gps.location.lng());
  lastDistance *= 3.281; //Meters to feet
  if(lastMaxSpeed > maxSpeed)
    maxSpeed = lastMaxSpeed;
  if(lastMaxSpeed > ATMaxSpeed)
    ATMaxSpeed = lastMaxSpeed;
  
  distance += lastDistance;
  ATDistance += lastDistance;

  time += lastTime;
  ATTime += lastTime;

  lastAvg = (lastDistance/lastTime) *0.682; //feet/sec to MPH
  avg = (distance/time) *0.682; //feet/sec to MPH
  ATAvg = (ATDistance/ATTime) *0.682; //feet/sec to MPH
  
  GPSDataRecorder::storeData();
}

void GPSDataRecorder::storeData() {
  preferences.putFloat(maxSpeedKey.c_str(), ATMaxSpeed);
  preferences.putFloat(distanceKey.c_str(), ATDistance);
  preferences.putUInt(timeKey.c_str(), ATTime);
}

void GPSDataRecorder::resetStats(bool last, bool today, bool allTime){
  if(last){
    lastMaxSpeed = 0.0;
    lastDistance = 0.0;
    lastTime = 0.0;
  }
  if(today){
    maxSpeed = 0.0;
    distance = 0.0;
    time = 0.0;
  }
  if(allTime){  
    ATMaxSpeed = 0.0; //All time max speed get from spiffs
    ATDistance = 0.0;  //all time distance 
    ATTime = 0.0;   //all combined time 
  }
  GPSDataRecorder::storeData();
}

float gpsError = 3;

double homeLat; 
double homeLng; 

double latitudes[4];
double longitudes[4];

void printDouble( double val, unsigned int precision){
// prints val with number of decimal places determine by precision
// NOTE: precision is 1 followed by the number of zeros for the desired number of decimial places
// example: printDouble( 3.1415, 100); // prints 3.14 (two decimal places)

    Serial.print (int(val));  //prints the int part
    Serial.print("."); // print the decimal point
    unsigned int frac;
    if(val >= 0)
        frac = (val - int(val)) * precision;
    else
        frac = (int(val)- val ) * precision;
    Serial.println(frac,DEC) ;
} 

void collectCoordinates(){
  logger.log("Collecting GPS Data, Please Wait");
  int i = 0;
  while(i<4){
    while (ss.available() > 0){
      gps.encode(ss.read());
      if (gps.location.isUpdated()){
        if(i == 5){
          printDouble(gps.location.lat(), 10000);
          printDouble(gps.location.lng(), 10000);
        }
        latitudes[i] = gps.location.lat();
        longitudes[i] = gps.location.lng();
        i++;
      }
    }
  }
  delay(500);
  Serial.print("Here is one lat and long: ");
  Serial.print(latitudes[5]);
  Serial.println(longitudes[5]);
}

double mapD(double x, double in_min, double in_max, double out_min, double out_max)
{
  return (x - in_min) * (out_max - out_min) / (in_max - in_min) + out_min;
}

//Generated by ChatGPT
double averageLatitude = 0.0;
double averageLongitude = 0.0;

double generateGPSLock()
{
    collectCoordinates();
    Serial.println("i made it past collection");

    // Variables for sum, squared sum, average, and standard deviation
    double sum = 0.0;
    double squaredSum = 0.0;
    double averageDistance = 0.0;
    double standardDeviation = 0.0;

    // Variables for average latitude and longitude
    double sumLatitude = 0.0;
    double sumLongitude = 0.0;

    // Variables for count and distance calculation
    double count = 0.0;
    double distance = 0.0;

    // Iterate through the arrays and calculate distances
    for (int i = 0; i < 3; ++i)
    {
        for (int j = i + 1; j < 4; ++j)
        {
            distance = gps.distanceBetween(latitudes[i], longitudes[i], latitudes[j], longitudes[j]);
            sum += distance;
            squaredSum += distance * distance;
            count++;

            sumLatitude += latitudes[i] + latitudes[j];
            sumLongitude += longitudes[i] + longitudes[j];
        }
    }

    // Calculate the average distance
    if (count > 0)
        averageDistance = sum / count;

    // Calculate the standard deviation
    if (count > 1)
    {
        double meanSquare = squaredSum / count;
        double mean = sum / count;
        standardDeviation = std::sqrt(meanSquare - mean * mean);
    }

    // Calculate the average latitude and longitude
    if (count > 0)
    {
        averageLatitude = sumLatitude / (2 * count);
        averageLongitude = sumLongitude / (2 * count);
    }

    // Output the average distance, average latitude, and average longitude
    logger.log("Average Distance: ", true);
    logger.log(averageDistance);
    logger.log("Standard Deviation: ", true);
    logger.log(standardDeviation);
    logger.log("Average Latitude: ", true);
    logger.log(averageLatitude);
    logger.log("Average Longitude: ", true);
    logger.log(averageLongitude);
  return standardDeviation;
}

void resetGPShome(){
  int attempts = 0;
  bool success = false;
  setBeep(200);
  while(!success){
    logger.log("Attempting to obtain GPS Lock", true);
    double deviation = generateGPSLock();
    deviation = mapD(deviation,0.0, 0.25, 0.0, 10.0);
    logger.log("Mapped Deviation ", true);
    logger.log(deviation);
    if(deviation <= gpsError){
      success = true;
      setBeep(400);
    }
    else{
      attempts++;
      if(attempts >=5){
        logger.log("unable to read a stable GPS position with that GPS Error Margin");
        success = true;
        setBeep(1500);
        return;
      }
    }
  }

  homeLat = averageLatitude;
  homeLng = averageLongitude;
  logger.log("GPS reset", true);
  logger.log(homeLat,false);
  logger.log(" ", false);
  logger.log(homeLng,false);
}

int satelliteLock(){
  return int(gps.satellites.value());
}

void setupGPS(){
  Serial.begin(115200);
  ss.begin(GPSBaud);
}

void loopGPS(){
  // This sketch displays information every time a new sentence is correctly encoded.
  //logger.log("gps Looping",true);
  while (ss.available() > 0){
    //logger.log("Serial available", true);
    gps.encode(ss.read());
    // if (gps.location.isUpdated()){
    //   // logger.log("gps reading", true);
    //   // Serial.print("Latitude= "); 
    //   // Serial.print(gps.location.lat(), 6);
    //   // Serial.print(" Longitude= "); 
    //   // Serial.println(gps.location.lng(), 6);
    //   // // Number of satellites in use (u32) hello
    //   // Serial.print("Number of satellites in use = "); 
    //   // Serial.println(gps.satellites.value());
    // }
  }
}

double getDistanceToEnd(){
  double distanceBetween = gps.distanceBetween(homeLat, homeLng, gps.location.lat(), gps.location.lng());
  // Serial.print(">Distance: ");
  // Serial.println(distanceBetween);
  return distanceBetween;
}
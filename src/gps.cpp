#include <gps.h>
#include <Arduino.h>
#include <SoftwareSerial.h>
#include <TinyGPS++.h>
#include <serverESP.h>

// The TinyGPS++ object
TinyGPSPlus gps;

static const int RXPin = 16, TXPin = 17;
static const uint32_t GPSBaud = 9600;

// The serial connection to the GPS device
SoftwareSerial ss(RXPin, TXPin);

float gpsError = 3;

double homeLat; 
double homeLng; 

double latitudes[4];
double longitudes[4];

void printDouble( double val, unsigned int precision){
// prints val with number of decimal places determine by precision
// NOTE: precision is 1 followed by the number of zeros for the desired number of decimial places
// example: printDouble( 3.1415, 100); // prints 3.14 (two decimal places)

    Serial.print (int(val));  //prints the int part
    Serial.print("."); // print the decimal point
    unsigned int frac;
    if(val >= 0)
        frac = (val - int(val)) * precision;
    else
        frac = (int(val)- val ) * precision;
    Serial.println(frac,DEC) ;
} 

void collectCoordinates(){
  logger.log("Collecting GPS Data, Please Wait");
  int i = 0;
  while(i<4){
    while (ss.available() > 0){
      gps.encode(ss.read());
      if (gps.location.isUpdated()){
        if(i == 5){
          printDouble(gps.location.lat(), 10000);
          printDouble(gps.location.lng(), 10000);
        }
        latitudes[i] = gps.location.lat();
        longitudes[i] = gps.location.lng();
        i++;
      }
    }
  }
  delay(500);
  Serial.print("Here is one lat and long: ");
  Serial.print(latitudes[5]);
  Serial.println(longitudes[5]);
}

double mapD(double x, double in_min, double in_max, double out_min, double out_max)
{
  return (x - in_min) * (out_max - out_min) / (in_max - in_min) + out_min;
}

//Generated by ChatGPT
double averageLatitude = 0.0;
double averageLongitude = 0.0;

double generateGPSLock()
{
    collectCoordinates();
    Serial.println("i made it past collection");

    // Variables for sum, squared sum, average, and standard deviation
    double sum = 0.0;
    double squaredSum = 0.0;
    double averageDistance = 0.0;
    double standardDeviation = 0.0;

    // Variables for average latitude and longitude
    double sumLatitude = 0.0;
    double sumLongitude = 0.0;

    // Variables for count and distance calculation
    double count = 0.0;
    double distance = 0.0;

    // Iterate through the arrays and calculate distances
    for (int i = 0; i < 3; ++i)
    {
        for (int j = i + 1; j < 4; ++j)
        {
            distance = gps.distanceBetween(latitudes[i], longitudes[i], latitudes[j], longitudes[j]);
            sum += distance;
            squaredSum += distance * distance;
            count++;

            sumLatitude += latitudes[i] + latitudes[j];
            sumLongitude += longitudes[i] + longitudes[j];
        }
    }

    // Calculate the average distance
    if (count > 0)
        averageDistance = sum / count;

    // Calculate the standard deviation
    if (count > 1)
    {
        double meanSquare = squaredSum / count;
        double mean = sum / count;
        standardDeviation = std::sqrt(meanSquare - mean * mean);
    }

    // Calculate the average latitude and longitude
    if (count > 0)
    {
        averageLatitude = sumLatitude / (2 * count);
        averageLongitude = sumLongitude / (2 * count);
    }

    // Output the average distance, average latitude, and average longitude
    logger.log("Average Distance: ", true);
    logger.log(averageDistance);
    logger.log("Standard Deviation: ", true);
    logger.log(standardDeviation);
    logger.log("Average Latitude: ", true);
    logger.log(averageLatitude);
    logger.log("Average Longitude: ", true);
    logger.log(averageLongitude);
  return standardDeviation;
}

void resetGPShome(){
  int attempts = 0;
  bool success = false;
  while(!success){
    logger.log("Attempting to obtain GPS Lock", true);
    double deviation = generateGPSLock();
    deviation = mapD(deviation,0.0, 0.25, 0.0, 10.0);
    logger.log("Mapped Deviation ", true);
    logger.log(deviation);
    if(deviation <= gpsError){
      success = true;
    }
    else{
      attempts++;
      if(attempts >=5){
        logger.log("unable to read a stable GPS position with that GPS Error Margin");
        return;
      }
    }
  }

  homeLat = averageLatitude;
  homeLng = averageLongitude;
  logger.log("GPS reset", true);
  logger.log(homeLat,false);
  logger.log(" ", false);
  logger.log(homeLng,false);
}

int satelliteLock(){
  return int(gps.satellites.value());
}


void setupGPS(){
  Serial.begin(115200);
  ss.begin(GPSBaud);
}

void loopGPS(){
  // This sketch displays information every time a new sentence is correctly encoded.
  while (ss.available() > 0){
    gps.encode(ss.read());
    if (gps.location.isUpdated()){

      // Serial.print("Latitude= "); 
      // Serial.print(gps.location.lat(), 6);
      // Serial.print(" Longitude= "); 
      // Serial.println(gps.location.lng(), 6);
      // // Number of satellites in use (u32) hello
      // Serial.print("Number of satellites in use = "); 
      // Serial.println(gps.satellites.value());
    }
  }
}

double getDistanceToEnd(){
  double distanceBetween = gps.distanceBetween(homeLat, homeLng, gps.location.lat(), gps.location.lng());
  Serial.print(">Distance: ");
  Serial.println(distanceBetween);
  return distanceBetween;
}

